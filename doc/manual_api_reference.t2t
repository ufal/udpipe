UDPipe API Reference
====================

The UDPipe API is defined in header ``udpipe.h`` and resides in
``ufal::udpipe`` namespace. The API allows only using existing models,
for custom model creation you have to use the ``train_parser`` binary.

The strings used in the UDPipe API are always UTF-8 encoded (except from
file paths, whose encoding is system dependent).


== UDPipe Versioning ==[versioning]

UDPipe is versioned using [Semantic Versioning http://semver.org/].
Therefore, a version consists of three numbers //major.minor.patch//, optionally
followed by a hyphen and pre-release version info, with the following semantics:

- Stable versions have no pre-release version info, development have non-empty
  pre-release version info.
- Two versions with the same //major.minor// have the same API with the same
  behaviour, apart from bugs. Therefore, if only //patch// is increased, the
  new version is only a bug-fix release.
- If two versions //v// and //u// have the same //major//, but //minor(v)// is
  greater than //minor(u)//, version //v// contains only additions to the API.
  In other words, the API of //u// is all present in //v// with the same
  behaviour (once again apart from bugs). It is therefore safe to upgrade to
  a newer UDPipe version with the same //major//.
- If two versions differ in //major//, their API may differ in any way.


Models created by UDPipe have the same behaviour in all UDPipe
versions with same //major//, apart from obvious bugfixes. On the other hand,
models created from the same data by different //major.minor// UDPipe
versions may have different behaviour.

== Struct string_piece ==[string_piece]
```
struct string_piece {
  const char* str;
  size_t len;

  string_piece();
  string_piece(const char* str);
  string_piece(const char* str, size_t len);
  string_piece(const std::string& str);
}
```

The [``string_piece`` #string_piece] is used for efficient string passing. The string
referenced in [``string_piece`` #string_piece] is not owned by it, so users have to make sure
the referenced string exists as long as the [``string_piece`` #string_piece].

== Class word ==[node]
```
class word {
 public:
  int id;         // 0 is root, >0 is sentence word, <0 is undefined
  string form;    // form
  string lemma;   // lemma
  string upostag; // universal part-of-speech tag
  string xpostag; // language-specific part-of-speech tag
  string feats;   // list of morphological features
  int head;       // head, 0 is root, <0 is undefined
  string deprel;  // dependency relation to the head
  string deps;    // secondary dependencies
  string misc;    // miscellaneous information

  vector<int> children;

  word(int id = -1, string_piece form = string_piece());
};
```

The [``word`` #word] class represents a sentence word.
The [``word`` #word] fields correspond to [CoNLL-U fields http://universaldependencies.org/docs/format.html],
with the ``children`` field representing the opposite direction of ``head`` links.

== Class multiword_token ==[multiword_token]
```
class multiword_token {
 public:
  int id_first, id_last;
  string form;
  string misc;

  multiword_token(int id_first = -1, int id_last = -1, string_piece form = string_piece(), string_piece misc = string_piece());
};
```

== Class sentence ==[sentence]
```
class sentence {
 public:
  sentence();

  vector<word> words;
  vector<multiword_token> multiword_tokens;
  vector<string> comments;
  static const string root_form;

  bool empty();
  void clear();
  word& add_word(string_piece form = string_piece());
  void set_head(int id, int head, const string& deprel);
  void unlink_all_words();
};
```

== Class input_format ==[input_format]
```
class input_format {
 public:
  virtual ~input_format() {}

  virtual bool read_block(istream& is, string& block) const = 0;
  virtual void set_text(string_piece text, bool make_copy = false) = 0;
  virtual bool next_sentence(sentence& s, string& error) = 0;

  // Static factory methods
  static input_format* new_input_format(const string& name);
  static input_format* new_conllu_input_format();
  static input_format* new_horizontal_input_format();
  static input_format* new_vertical_input_format();
};
```

== Class output_format ==[output_format]
```
class output_format {
 public:
  virtual ~output_format() {}

  virtual void write_sentence(const sentence& s, ostream& os) = 0;
  virtual void finish_document(ostream& os) {};

  // Static factory methods
  static output_format* new_output_format(const string& name);
  static output_format* new_conllu_output_format();
  static output_format* new_horizontal_output_format();
  static output_format* new_vertical_output_format();
};
```

== Class model ==[model]
```
class model {
 public:
  virtual ~model() {}

  static model* load(const char* fname);
  static model* load(istream& is);

  virtual input_format* new_tokenizer(const string& options) const = 0;
  virtual bool tag(sentence& s, const string& options, string& error) const = 0;
  virtual bool parse(sentence& s, const string& options, string& error) const = 0;

  static const string DEFAULT;
};
```

== Class pipeline ==[pipeline]
```
class pipeline {
 public:
  pipeline(const model* m, const string& input, const string& tagger, const string& parser, const string& output);

  void set_model(const model* m);
  void set_input(const string& input);
  void set_tagger(const string& tagger);
  void set_parser(const string& parser);
  void set_output(const string& output);

  bool process(istream& is, ostream& os, string& error) const;

  static const string DEFAULT;
  static const string NONE;
};
```

== Class trainer ==[trainer]
```
class trainer {
 public:
  static bool train(const string& method, const vector<sentence>& train, const vector<sentence>& heldout,
                    const string& tokenizer, const string& tagger, const string& parser,
                    ostream& os, string& error);

  static const string DEFAULT;
  static const string NONE;
};
```

== Class evaluator ==[evaluator]
```
class evaluator {
 public:
  evaluator(const model* m, const string& tokenizer, const string& tagger, const string& parser);

  void set_model(const model* m);
  void set_tokenizer(const string& tokenizer);
  void set_tagger(const string& tagger);
  void set_parser(const string& parser);

  bool evaluate(istream& is, ostream& os, string& error) const;

  static const string DEFAULT;
  static const string NONE;
};
```

== Class version ==[version]
```
class version {
 public:
  unsigned major;
  unsigned minor;
  unsigned patch;
  string prerelease;

  static [version #version] [current #version_current]();
};
```

The [``version`` #version] class represents UDPipe version.
See [UDPipe Versioning #versioning] for more information.

=== version::current ===[version_current]
``` static [version #version] current();

Returns current UDPipe version.


== C++ Bindings API ==[cpp_bindings_api]

Bindings for other languages than C++ are created using SWIG from the C++
bindings API, which is a slightly modified version of the native C++ API.
Main changes are replacement of [``string_piece`` #string_piece] type by native
strings and removal of methods using ``istream``. Here is the C++ bindings API
declaration:

%!include: manual_bindings_api.t2t

== C# Bindings ==[csharp_bindings]

%!include: manual_bindings_csharp_api.t2t

== Java Bindings ==[java_bindings]

%!include: manual_bindings_java_api.t2t

== Perl Bindings ==[perl_bindings]

%!include: manual_bindings_perl_api.t2t

== Python Bindings ==[python_bindings]

%!include: manual_bindings_python_api.t2t
